@using Eidos.Models
@using Eidos.Models.Enums
@using Eidos.Services
@using Eidos.Services.Interfaces
@using Eidos.Components.Shared
@inject ILogger<ConceptManagementPanel> Logger
@inject IUserPreferencesService PreferencesService
@inject ToastService ToastService

<AddConceptFloatingPanel @ref="addConceptFloatingPanel"
                         IsVisible="@(showAddConcept || editingConcept != null)"
                         IsVisibleChanged="@((visible) => { if (!visible) _ = CancelEditConcept(); })"
                         OnClose="@CancelEditConcept"
                         IsEditing="@(editingConcept != null)"
                         ShouldPulse="@ShouldPulse"
                         PanelSize="@FloatingPanel.PanelSize.Standard"
                         CustomTemplates="@CustomTemplates"
                         ConceptName="@newConcept.Name"
                         ConceptNameChanged="@((value) => newConcept.Name = value)"
                         ConceptCategory="@newConcept.Category"
                         ConceptCategoryChanged="@OnConceptCategoryChanged"
                         ConceptExplanation="@newConcept.SimpleExplanation"
                         ConceptExplanationChanged="@((value) => newConcept.SimpleExplanation = value)"
                         ConceptExamples="@newConcept.Examples"
                         ConceptExamplesChanged="@((value) => newConcept.Examples = value)"
                         ConceptColor="@newConcept.Color"
                         ConceptColorChanged="@((value) => newConcept.Color = value)"
                         OnSaveClick="@SaveConcept"
                         OnSaveAndAddAnotherClick="@SaveConceptAndAddAnother"
                         OnCancelClick="@CancelEditConcept"
                         OnTemplateSelected="@ApplyConceptTemplate" />

@code {
    // Component references
    private AddConceptFloatingPanel? addConceptFloatingPanel;

    // Parameters
    [Parameter, EditorRequired] public int OntologyId { get; set; }
    [Parameter] public ICollection<CustomConceptTemplate> CustomTemplates { get; set; } = new List<CustomConceptTemplate>();
    [Parameter] public bool ShouldPulse { get; set; } = false;
    [Parameter] public PermissionLevel? UserPermissionLevel { get; set; }

    // EventCallbacks for parent communication
    [Parameter] public EventCallback<Concept> OnConceptCreated { get; set; }
    [Parameter] public EventCallback<Concept> OnConceptUpdated { get; set; }
    [Parameter] public EventCallback<int> OnConceptDeleted { get; set; }
    [Parameter] public EventCallback OnCancelRequested { get; set; }

    // Internal state
    private bool showAddConcept = false;
    private Concept? editingConcept = null;
    private Concept newConcept = new();

    /// <summary>
    /// Shows the add concept dialog with a new blank concept.
    /// </summary>
    public async Task ShowAddConceptDialog()
    {
        try
        {
            var prefs = await PreferencesService.GetCurrentUserPreferencesAsync();

            newConcept = new Concept
            {
                OntologyId = OntologyId,
                Color = prefs.DefaultConceptColor
            };

            Logger.LogInformation("Applied default color {Color} from preferences", prefs.DefaultConceptColor);
        }
        catch (Exception ex)
        {
            // Fallback to random color if preferences fail to load
            Logger.LogError(ex, "Failed to load user preferences for concept creation, using random color");
            newConcept = new Concept
            {
                OntologyId = OntologyId,
                Color = "#" + Random.Shared.Next(0x1000000).ToString("X6")
            };
        }

        showAddConcept = true;
        editingConcept = null;
        StateHasChanged();
    }

    /// <summary>
    /// Shows the edit concept dialog for an existing concept.
    /// </summary>
    /// <param name="concept">The concept to edit.</param>
    public void ShowEditConceptDialog(Concept concept)
    {
        editingConcept = concept;
        newConcept = new Concept
        {
            Id = concept.Id,
            OntologyId = concept.OntologyId,
            Name = concept.Name,
            Category = concept.Category,
            SimpleExplanation = concept.SimpleExplanation,
            Definition = concept.Definition,
            Examples = concept.Examples,
            Color = concept.Color,
            SourceOntology = concept.SourceOntology
        };
        showAddConcept = true;
        StateHasChanged();
    }

    /// <summary>
    /// Shows the duplicate concept dialog with a copy of the concept.
    /// </summary>
    /// <param name="concept">The concept to duplicate.</param>
    public Task ShowDuplicateConceptDialog(Concept concept)
    {
        newConcept = new Concept
        {
            OntologyId = OntologyId,
            Name = $"{concept.Name} (Copy)",
            Category = concept.Category,
            SimpleExplanation = concept.SimpleExplanation,
            Definition = concept.Definition,
            Examples = concept.Examples,
            Color = concept.Color,
            SourceOntology = concept.SourceOntology
        };
        editingConcept = null;
        showAddConcept = true;
        StateHasChanged();

        ToastService.ShowInfo($"Ready to create copy of \"{concept.Name}\". Click 'Add' to save or 'Cancel' to discard.", 5000);
        return Task.CompletedTask;
    }

    /// <summary>
    /// Hides the concept dialog.
    /// </summary>
    public void HideDialog()
    {
        showAddConcept = false;
        editingConcept = null;
        newConcept = new Concept();
        StateHasChanged();
    }

    /// <summary>
    /// Focuses the name input field in the concept editor.
    /// </summary>
    public async Task FocusNameInput()
    {
        if (addConceptFloatingPanel != null)
        {
            await addConceptFloatingPanel.FocusNameInput();
        }
    }

    private async Task OnConceptCategoryChanged(string? category)
    {
        newConcept.Category = category;

        // Auto-apply color based on category if preferences allow
        try
        {
            var prefs = await PreferencesService.GetCurrentUserPreferencesAsync();

            if (prefs.AutoColorByCategory)
            {
                newConcept.Color = prefs.GetColorForCategory(category);
                Logger.LogInformation("Auto-applied color {Color} for category {Category}", newConcept.Color, category);
            }
            else
            {
                Logger.LogInformation("AutoColorByCategory is disabled, not changing color for category {Category}", category);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to auto-apply color for category {Category}", category);
        }
    }

    private async Task SaveConcept()
    {
        if (string.IsNullOrWhiteSpace(newConcept.Name))
            return;

        // Check permissions
        if (editingConcept != null && !CanEdit())
        {
            ToastService.ShowError("You do not have permission to edit concepts");
            return;
        }
        else if (editingConcept == null && !CanAdd())
        {
            ToastService.ShowError("You do not have permission to add concepts");
            return;
        }

        try
        {
            if (editingConcept != null)
            {
                await OnConceptUpdated.InvokeAsync(newConcept);
                ToastService.ShowSuccess($"Updated concept \"{newConcept.Name}\"");
                editingConcept = null;
            }
            else
            {
                await OnConceptCreated.InvokeAsync(newConcept);
                ToastService.ShowSuccess($"Created concept \"{newConcept.Name}\"");
            }

            showAddConcept = false;
            newConcept = new Concept();
        }
        catch (Exception ex)
        {
            var errorMessage = ex.InnerException != null
                ? $"{ex.Message} - {ex.InnerException.Message}"
                : ex.Message;
            ToastService.ShowError($"Failed to save concept: {errorMessage}", 8000);
        }
    }

    private async Task SaveConceptAndAddAnother()
    {
        if (string.IsNullOrWhiteSpace(newConcept.Name))
            return;

        // Check permissions
        if (!CanAdd())
        {
            ToastService.ShowError("You do not have permission to add concepts");
            return;
        }

        try
        {
            var conceptName = newConcept.Name;
            await OnConceptCreated.InvokeAsync(newConcept);
            ToastService.ShowSuccess($"Created concept \"{conceptName}\"", 2000);

            // Get user preferences for the new concept defaults
            var prefs = await PreferencesService.GetCurrentUserPreferencesAsync();

            // Clear the form with fresh defaults
            newConcept = new Concept
            {
                OntologyId = OntologyId,
                Color = prefs.DefaultConceptColor,
                Category = newConcept.Category // Keep the same category for convenience
            };

            // Keep the form open
            showAddConcept = true;
            StateHasChanged();

            // Focus the name input field
            if (addConceptFloatingPanel != null)
            {
                await addConceptFloatingPanel.FocusNameInput();
            }
        }
        catch (Exception ex)
        {
            var errorMessage = ex.InnerException != null
                ? $"{ex.Message} - {ex.InnerException.Message}"
                : ex.Message;
            ToastService.ShowError($"Failed to save concept: {errorMessage}", 8000);
        }
    }

    private async Task CancelEditConcept()
    {
        showAddConcept = false;
        editingConcept = null;
        newConcept = new Concept();
        await OnCancelRequested.InvokeAsync();
    }

    private void ApplyConceptTemplate(string templateValue)
    {
        if (string.IsNullOrWhiteSpace(templateValue))
            return;

        // Check if it's a custom template (format: "custom:123") or default (format: "default:Entity")
        if (templateValue.StartsWith("custom:"))
        {
            var templateIdStr = templateValue.Substring(7); // Remove "custom:" prefix
            if (int.TryParse(templateIdStr, out var templateId))
            {
                var customTemplate = CustomTemplates.FirstOrDefault(t => t.Id == templateId);
                if (customTemplate != null)
                {
                    newConcept.Category = customTemplate.Category;
                    newConcept.SimpleExplanation = customTemplate.Description;
                    newConcept.Examples = customTemplate.Examples;
                    newConcept.Color = customTemplate.Color;
                    ToastService.ShowInfo($"Applied custom template '{customTemplate.Category}' - customize as needed");
                }
            }
        }
        else if (templateValue.StartsWith("default:"))
        {
            var templateCategory = templateValue.Substring(8); // Remove "default:" prefix
            var template = CommonConceptTemplates.Templates.FirstOrDefault(t => t.Category == templateCategory);
            if (template != null)
            {
                newConcept.Category = template.Category;
                newConcept.SimpleExplanation = template.Description;
                newConcept.Examples = template.Examples;
                newConcept.Color = template.Color;
                ToastService.ShowInfo($"Applied {template.Category} template - customize as needed");
            }
        }
    }

    private bool CanAdd() => UserPermissionLevel.HasValue && UserPermissionLevel.Value >= PermissionLevel.ViewAndAdd;
    private bool CanEdit() => UserPermissionLevel.HasValue && UserPermissionLevel.Value >= PermissionLevel.ViewAddEdit;
}
