@using Eidos.Models.DTOs
@using System.Net.Http.Json
@using Microsoft.AspNetCore.Components.Authorization
@inject HttpClient Http
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject ILogger<CommentThread> Logger

<div class="comment-thread">
    @if (IsLoading)
    {
        <div class="text-center py-3">
            <div class="spinner-border spinner-border-sm text-primary" role="status">
                <span class="visually-hidden">Loading comments...</span>
            </div>
        </div>
    }
    else if (Comments.Count == 0)
    {
        <div class="no-comments text-muted text-center py-3">
            <i class="bi bi-chat-left-text"></i>
            <p class="mb-0 mt-2">No comments yet. Be the first to comment!</p>
        </div>
    }
    else
    {
        <div class="comments-list">
            @foreach (var comment in Comments)
            {
                <CommentItem Comment="comment"
                             OnReply="HandleReply"
                             OnEdit="HandleEdit"
                             OnDelete="HandleDelete"
                             OnResolve="HandleResolve" />
            }
        </div>
    }

    @if (ShowEditor)
    {
        <div class="comment-editor-container mt-3">
            <CommentEditor OntologyId="@OntologyId"
                          EntityType="@EntityType"
                          EntityId="@EntityId"
                          ParentCommentId="@ParentCommentId"
                          OnCommentSubmitted="@HandleCommentSubmitted"
                          OnCancel="@HandleEditorCancel" />
        </div>
    }
    else if (CanComment)
    {
        <div class="add-comment-button mt-3">
            <button class="btn btn-sm btn-outline-primary" @onclick="ShowCommentEditor">
                <i class="bi bi-chat-left-text"></i> Add Comment
            </button>
        </div>
    }
</div>

@code {
    [Parameter, EditorRequired]
    public int OntologyId { get; set; }

    [Parameter, EditorRequired]
    public string EntityType { get; set; } = string.Empty;

    [Parameter, EditorRequired]
    public int EntityId { get; set; }

    [Parameter]
    public bool ShowResolvedThreads { get; set; } = true;

    [Parameter]
    public EventCallback<List<CommentResponse>> OnCommentsLoaded { get; set; }

    private List<CommentResponse> Comments { get; set; } = new();
    private bool IsLoading { get; set; } = true;
    private bool ShowEditor { get; set; } = false;
    private int? ParentCommentId { get; set; } = null;
    private bool CanComment { get; set; } = false;
    private string CurrentUserId { get; set; } = string.Empty;

    protected override async Task OnInitializedAsync()
    {
        await LoadCurrentUser();
        await LoadComments();
        await CheckPermissions();
    }

    protected override async Task OnParametersSetAsync()
    {
        // Reload comments if entity changes
        if (EntityId != 0)
        {
            await LoadComments();
        }
    }

    private async Task LoadCurrentUser()
    {
        var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;

        if (user.Identity?.IsAuthenticated == true)
        {
            CurrentUserId = user.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)?.Value ?? string.Empty;
        }
    }

    private async Task LoadComments()
    {
        try
        {
            IsLoading = true;
            StateHasChanged();

            Console.WriteLine($"[CommentThread] LoadComments - OntologyId: {OntologyId}, EntityType: {EntityType}, EntityId: {EntityId}");
            var response = await Http.GetAsync($"/api/ontologies/{OntologyId}/comments/{EntityType}/{EntityId}");
            Console.WriteLine($"[CommentThread] Response status: {response.StatusCode}");

            if (response.IsSuccessStatusCode)
            {
                var comments = await response.Content.ReadFromJsonAsync<List<CommentResponse>>();

                if (comments != null)
                {
                    // Filter resolved threads if needed
                    if (!ShowResolvedThreads)
                    {
                        Comments = comments.Where(c => !c.IsResolved).ToList();
                    }
                    else
                    {
                        Comments = comments;
                    }

                    await OnCommentsLoaded.InvokeAsync(Comments);
                }
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading comments for {EntityType} {EntityId}", EntityType, EntityId);
        }
        finally
        {
            IsLoading = false;
            StateHasChanged();
        }
    }

    private Task CheckPermissions()
    {
        // Permission is checked by having the "Add Comment" button visible
        // The API will validate permissions server-side
        CanComment = !string.IsNullOrEmpty(CurrentUserId);
        return Task.CompletedTask;
    }

    private void ShowCommentEditor()
    {
        ParentCommentId = null;
        ShowEditor = true;
    }

    private async Task HandleReply(int commentId)
    {
        ParentCommentId = commentId;
        ShowEditor = true;
        StateHasChanged();
    }

    private async Task HandleEdit(CommentResponse comment)
    {
        // Edit will be handled by CommentItem component
        StateHasChanged();
    }

    private async Task HandleDelete(int commentId)
    {
        try
        {
            var response = await Http.DeleteAsync($"/api/ontologies/{OntologyId}/comments/{commentId}");
            if (response.IsSuccessStatusCode)
            {
                await LoadComments();
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error deleting comment {CommentId}", commentId);
        }
    }

    private async Task HandleResolve((int CommentId, bool Resolve) args)
    {
        try
        {
            var endpoint = args.Resolve ? "resolve" : "unresolve";
            var response = await Http.PostAsync($"/api/ontologies/{OntologyId}/comments/{args.CommentId}/{endpoint}", null);

            if (response.IsSuccessStatusCode)
            {
                await LoadComments();
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error {Action} comment {CommentId}", args.Resolve ? "resolving" : "unresolving", args.CommentId);
        }
    }

    private async Task HandleCommentSubmitted(CommentResponse newComment)
    {
        ShowEditor = false;
        ParentCommentId = null;
        await LoadComments();
    }

    private void HandleEditorCancel()
    {
        ShowEditor = false;
        ParentCommentId = null;
        StateHasChanged();
    }

    public async Task RefreshComments()
    {
        await LoadComments();
    }

    public async Task AddCommentFromSignalR(CommentResponse comment)
    {
        // Check if this comment belongs to this entity
        if (comment.EntityType == EntityType && comment.EntityId == EntityId)
        {
            await LoadComments();
        }
    }

    public async Task UpdateCommentFromSignalR(CommentResponse comment)
    {
        await LoadComments();
    }

    public async Task RemoveCommentFromSignalR(int commentId)
    {
        await LoadComments();
    }
}
