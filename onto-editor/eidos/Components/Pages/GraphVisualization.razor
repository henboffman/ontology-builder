@using Eidos.Models
@using Eidos.Services.Interfaces
@using Microsoft.JSInterop
@inject IJSRuntime JS
@inject IUserPreferencesService PreferencesService

<div style="position: relative; width: 100%; height: @Height;">
    <div id="@GraphId" style="width: 100%; height: 100%; border: 1px solid var(--border-color); border-radius: 0.375rem; background-color: var(--canvas-bg);"></div>

    <!-- Text Size Control Overlay -->
    <div style="position: absolute; top: 10px; right: 10px; background: var(--card-bg); padding: 10px 15px; border-radius: 8px; box-shadow: var(--shadow); z-index: 1000; min-width: 180px;">
        <div class="d-flex flex-column gap-1">
            <label class="form-label small mb-1" style="font-weight: 600;">
                <i class="bi bi-fonts"></i> Text Size: @(textSizeScale)%
            </label>
            <input type="range" class="form-range" min="50" max="150" step="10"
                   value="@textSizeScale"
                   @oninput="OnTextSizeChanged"
                   style="cursor: pointer;" />
            <div class="d-flex justify-content-between">
                <small class="text-muted">50%</small>
                <small class="text-muted">150%</small>
            </div>
        </div>
    </div>
</div>

@code {
    [Parameter]
    public Ontology? Ontology { get; set; }

    [Parameter]
    public string Height { get; set; } = "600px";

    [Parameter]
    public string ColorMode { get; set; } = "concept"; // "concept" or "source"

    /// <summary>
    /// Controls whether individual instances are rendered in the graph alongside concepts.
    /// When true, adds three types of additional graph elements:
    /// 1. Individual nodes (diamond-shaped with 40% opacity colors derived from parent concept)
    /// 2. Instance-of edges (dotted lines connecting individuals to their parent concepts)
    /// 3. Individual relationship edges (purple lines connecting related individuals)
    /// </summary>
    /// <remarks>
    /// Visual styling for individuals:
    /// - Shape: Diamond (distinguishes from ellipse-shaped concepts)
    /// - Border: Dashed (visual indicator of instance vs. concept)
    /// - Color: rgba() format with 40% opacity of parent concept color
    /// - Size: 1.2x larger than concept nodes for better visibility
    ///
    /// Edge types:
    /// - instance-of: Dotted gray lines with vee arrows
    /// - individualRelationship: Solid purple (#7B68EE) lines with triangle arrows
    /// </remarks>
    [Parameter]
    public bool ShowIndividuals { get; set; } = false;

    [Parameter]
    public EventCallback<int> OnNodeCtrlClicked { get; set; }

    [Parameter]
    public EventCallback<int> OnNodeClicked { get; set; }

    [Parameter]
    public EventCallback<int> OnEdgeClicked { get; set; }

    [Parameter]
    public EventCallback<int> OnIndividualClicked { get; set; }

    [Parameter]
    public EventCallback OnBackgroundCmdShiftClicked { get; set; }

    private string GraphId = $"graph-{Guid.NewGuid():N}";
    private bool hasRendered = false;
    private int lastConceptCount = 0;
    private int lastRelationshipCount = 0;
    private int textSizeScale = 100; // Percentage scale for text size (50-150%)
    private bool preferencesLoaded = false;

    protected override async Task OnInitializedAsync()
    {
        // Load text size preference when component is created
        await LoadTextSizePreference();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && Ontology != null)
        {
            hasRendered = true;
            lastConceptCount = Ontology.Concepts.Count;
            lastRelationshipCount = Ontology.Relationships.Count;
            await RenderGraph();
        }
        else if (!firstRender && Ontology != null && hasRendered)
        {
            // Only re-render if the data has actually changed
            var currentConceptCount = Ontology.Concepts.Count;
            var currentRelationshipCount = Ontology.Relationships.Count;

            if (currentConceptCount != lastConceptCount || currentRelationshipCount != lastRelationshipCount)
            {
                lastConceptCount = currentConceptCount;
                lastRelationshipCount = currentRelationshipCount;
                await RenderGraph();
            }
        }
    }

    protected override void OnParametersSet()
    {
        // Don't call RenderGraph here - it will be called in OnAfterRenderAsync
        // This avoids the JavaScript interop issue during pre-rendering
    }

    private async Task LoadTextSizePreference()
    {
        if (preferencesLoaded)
            return;

        try
        {
            var prefs = await PreferencesService.GetCurrentUserPreferencesAsync();
            textSizeScale = prefs.TextSizeScale;
            if (textSizeScale == 0) // Handle old records that have default 0
            {
                textSizeScale = 100;
            }
            preferencesLoaded = true;
        }
        catch
        {
            // Use default 100 if preferences fail to load
            textSizeScale = 100;
            preferencesLoaded = true;
        }
    }

    private async Task RenderGraph()
    {
        if (Ontology == null || Ontology.Concepts.Count == 0)
            return;

        // Load user preferences for graph display
        UserPreferences? prefs = null;
        try
        {
            prefs = await PreferencesService.GetCurrentUserPreferencesAsync();
        }
        catch
        {
            // Use defaults if preferences fail to load
        }

        // Get unique source ontologies and assign colors
        var sourceOntologies = Ontology.Concepts
            .Select(c => c.SourceOntology ?? "Original")
            .Distinct()
            .ToList();

        var sourceColorMap = new Dictionary<string, string>();
        // Predefined color palette for graph nodes - matches CSS variables in themes.css
        // These correspond to: entity, function, quality, attribute, role, process, related, information
        // Note: Dark mode brightness adjustments are handled by CSS in graphVisualization.js
        var predefinedColors = new[] { "#4A90E2", "#E74C3C", "#6BCF7F", "#F4A261", "#9B59B6", "#E67E22", "#1ABC9C", "#3498DB" };

        for (int i = 0; i < sourceOntologies.Count; i++)
        {
            sourceColorMap[sourceOntologies[i]] = predefinedColors[i % predefinedColors.Length];
        }

        // Build nodes from concepts
        var nodes = Ontology.Concepts.Select(c =>
        {
            var nodeColor = ColorMode == "source"
                ? sourceColorMap[c.SourceOntology ?? "Original"]
                : (c.Color ?? "#4A90E2"); // Fallback to default concept color

            return new
            {
                data = new
                {
                    id = $"concept-{c.Id}",
                    label = c.Name,
                    color = nodeColor,
                    nodeType = "concept",
                    definition = c.Definition ?? "",
                    explanation = c.SimpleExplanation ?? "",
                    examples = c.Examples ?? "",
                    category = c.Category ?? "",
                    sourceOntology = c.SourceOntology ?? "Original"
                }
            };
        }).ToList();

        // ====================================================================================
        // Individual Node Visualization (Phase 1 of 3: Nodes)
        // ====================================================================================
        // Adds diamond-shaped nodes representing individual instances of concepts.
        // Design decisions:
        // - Color opacity: 40% of parent concept color for visual hierarchy
        // - Color format: rgba() required by Cytoscape.js (8-char hex with alpha not supported)
        // - Shape: Diamond with dashed border (defined in graphVisualization.js)
        // - Size: 1.2x concept node size for better visibility with diamond shape
        // ====================================================================================
        if (ShowIndividuals && Ontology.Individuals?.Any() == true)
        {
            var individualNodes = Ontology.Individuals.Select(ind =>
            {
                // Find the concept this individual is an instance of
                var concept = Ontology.Concepts.FirstOrDefault(c => c.Id == ind.ConceptId);
                var baseColor = concept?.Color ?? "#4A90E2";

                // Convert hex color to rgba format with 40% opacity
                // Note: Cytoscape.js requires rgba() format - does not support 8-character hex (#RRGGBBAA)
                var r = Convert.ToInt32(baseColor.Substring(1, 2), 16);
                var g = Convert.ToInt32(baseColor.Substring(3, 2), 16);
                var b = Convert.ToInt32(baseColor.Substring(5, 2), 16);
                var individualColor = $"rgba({r}, {g}, {b}, 0.4)";

                return new
                {
                    data = new
                    {
                        id = $"individual-{ind.Id}",
                        label = ind.Name ?? ind.Label ?? $"Individual {ind.Id}",
                        color = individualColor,
                        nodeType = "individual",
                        definition = ind.Description ?? "",
                        explanation = "", // Individuals don't have explanations
                        examples = "", // Individuals don't have examples
                        category = "", // Individuals don't have categories
                        sourceOntology = concept?.SourceOntology ?? "Original"
                    }
                };
            });

            nodes.AddRange(individualNodes);
        }

        // Build edges from relationships
        var edges = Ontology.Relationships.Select(r => new
        {
            data = new
            {
                id = $"rel-{r.Id}",
                source = $"concept-{r.SourceConceptId}",
                target = $"concept-{r.TargetConceptId}",
                label = r.RelationType,
                edgeType = "relationship",
                description = r.Description ?? ""
            }
        }).ToList();

        // ====================================================================================
        // Individual Visualization (Phase 2 of 3: Instance-of Edges)
        // ====================================================================================
        // Adds dotted edges connecting individuals to their parent concepts.
        // Visual style: Dotted gray lines with vee arrows (lighter than regular relationships)
        // Label: "instance of" to clearly indicate the type-instance relationship
        // ====================================================================================
        if (ShowIndividuals && Ontology.Individuals?.Any() == true)
        {
            var instanceEdges = Ontology.Individuals.Select(ind => new
            {
                data = new
                {
                    id = $"instance-{ind.Id}",
                    source = $"individual-{ind.Id}",
                    target = $"concept-{ind.ConceptId}",
                    label = "instance of",
                    edgeType = "instanceOf",
                    description = ""
                }
            });

            edges.AddRange(instanceEdges);
        }

        // ====================================================================================
        // Individual Visualization (Phase 3 of 3: Individual Relationship Edges)
        // ====================================================================================
        // Adds edges connecting related individuals (e.g., "Alice knows Bob").
        // Visual style: Solid purple (#7B68EE) lines with triangle arrows
        // These relationships are distinct from concept relationships and instance-of edges,
        // representing connections at the instance level rather than the ontology structure level.
        // ====================================================================================
        if (ShowIndividuals && Ontology.IndividualRelationships?.Any() == true)
        {
            var individualRelationshipEdges = Ontology.IndividualRelationships.Select(ir => new
            {
                data = new
                {
                    id = $"indrel-{ir.Id}",
                    source = $"individual-{ir.SourceIndividualId}",
                    target = $"individual-{ir.TargetIndividualId}",
                    label = ir.RelationType ?? "related to",
                    edgeType = "individualRelationship",
                    description = ir.Description ?? ""
                }
            });

            edges.AddRange(individualRelationshipEdges);
        }

        var elements = new
        {
            nodes,
            edges
        };

        // Create display options from user preferences
        // Explicitly type to avoid vararg calling convention issues
        int nodeSize = prefs?.DefaultNodeSize ?? 40;
        int edgeThickness = prefs?.DefaultEdgeThickness ?? 2;
        bool showEdgeLabels = prefs?.ShowEdgeLabels ?? true;
        double textScale = textSizeScale / 100.0; // Convert percentage to decimal (e.g., 100% = 1.0)

        var displayOptions = new
        {
            nodeSize = nodeSize,
            edgeThickness = edgeThickness,
            showEdgeLabels = showEdgeLabels,
            textSizeScale = textScale
        };

        var dotNetHelper = DotNetObjectReference.Create(this);
        await JS.InvokeVoidAsync("renderOntologyGraph", GraphId, elements, dotNetHelper, displayOptions);
    }

    [JSInvokable]
    public async Task OnNodeCtrlClick(int conceptId)
    {
        await OnNodeCtrlClicked.InvokeAsync(conceptId);
    }

    [JSInvokable]
    public async Task OnNodeClick(int conceptId)
    {
        await OnNodeClicked.InvokeAsync(conceptId);
    }

    [JSInvokable]
    public async Task OnEdgeClick(int relationshipId)
    {
        await OnEdgeClicked.InvokeAsync(relationshipId);
    }

    [JSInvokable]
    public async Task OnIndividualClick(int individualId)
    {
        await OnIndividualClicked.InvokeAsync(individualId);
    }

    [JSInvokable]
    public async Task OnBackgroundCmdShiftClick()
    {
        await OnBackgroundCmdShiftClicked.InvokeAsync();
    }

    public async Task RefreshGraph()
    {
        await RenderGraph();
    }

    private async Task OnTextSizeChanged(ChangeEventArgs e)
    {
        if (int.TryParse(e.Value?.ToString(), out int newSize))
        {
            textSizeScale = newSize;

            // Save to user preferences
            try
            {
                var prefs = await PreferencesService.GetCurrentUserPreferencesAsync();
                prefs.TextSizeScale = textSizeScale;
                await PreferencesService.UpdatePreferencesAsync(prefs);
            }
            catch
            {
                // Silently fail - text size will still work for this session
            }

            await RenderGraph();
        }
    }
}
